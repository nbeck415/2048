{"ast":null,"code":"import { dimension, DIRECTION } from \"./constants.js\"; // TO DO: detect if no empty tiles left\n// generates new num in random spot and updates board\n\nfunction newNum(tiles) {\n  let newTiles = tiles.slice();\n  let row = Math.floor(Math.random() * dimension);\n  let col = Math.floor(Math.random() * dimension);\n\n  if (tiles[row][col] === 0) {\n    newTiles[row][col] = 2;\n  } else {\n    newNum(tiles);\n  }\n\n  return newTiles;\n} // return random row or col index\n\n\nfunction getIndex() {\n  return Math.floor(Math.random() * dimension);\n} // side effect: modify shifted\n\n\nexport function merge(shifted, row1, col1, row2, col2) {\n  let currentVal = shifted[row1][col1];\n  let adjacentVal = shifted[row2][col2];\n  shifted[row1][col1] = currentVal + adjacentVal;\n  shifted[row2][col2] = 0;\n} // do \"sliding all the way\" when shift\n\nexport function slideUp(shifted, col) {\n  for (let row = 0; row < dimension - 1; row++) {\n    if (shifted[row][col] == 0) {\n      let row2 = row + 1;\n\n      while (row2 < dimension - 1 && shifted[row2][col] === 0) {\n        row2 += 1;\n      }\n\n      merge(shifted, row, col, row2, col);\n    }\n  }\n\n  return shifted;\n}\n\nfunction slideLeft(shifted, row) {\n  for (let col = 0; col < dimension - 1; col++) {\n    if (shifted[row][col] == 0) {\n      let col2 = col + 1;\n\n      while (col2 < dimension - 1 && shifted[row][col2] === 0) {\n        col2 += 1;\n      }\n\n      merge(shifted, row, col, row, col2);\n    }\n  }\n\n  return shifted;\n}\n\nfunction slideDown(shifted, col) {\n  for (let row = dimension - 1; row > 0; row--) {\n    if (shifted[row][col] == 0) {\n      let row2 = row - 1;\n\n      while (row2 > 0 && shifted[row2][col] === 0) {\n        row2 -= 1;\n      }\n\n      merge(shifted, row, col, row2, col);\n    }\n  }\n\n  return shifted;\n}\n\nfunction slideRight(shifted, row) {\n  for (let col = dimension - 1; col > 0; col--) {\n    if (shifted[row][col] == 0) {\n      let col2 = col - 1;\n\n      while (col2 > 0 && shifted[row][col2] === 0) {\n        col2 -= 1;\n      }\n\n      merge(shifted, row, col, row, col2);\n    }\n  }\n\n  return shifted;\n}\n\nexport function slideWholeBoard(shifted, direction) {\n  for (let col = 0; col < dimension; col++) {\n    switch (direction) {\n      case DIRECTION.UP:\n        slideUp(shifted, col);\n        break;\n\n      case DIRECTION.DOWN:\n        slideDown(shifted, col);\n        break;\n\n      case DIRECTION.LEFT:\n        slideLeft(shifted, col);\n        break;\n\n      case DIRECTION.RIGHT:\n        slideRight(shifted, col);\n        break;\n\n      default:\n        console.log('not a direction');\n      //do nothing\n    }\n  }\n} // modify board with merged tiles shifted up one\n\nfunction shiftUp(shifted) {\n  for (let row = 0; row < dimension - 1; row++) {\n    for (let col = 0; col < dimension; col++) {\n      let nextRow = row + 1;\n\n      if (shifted[row][col] === shifted[nextRow][col]) {\n        merge(shifted, row, col, nextRow, col);\n      }\n    }\n  }\n}\n\nfunction shiftLeft(shifted) {\n  for (let col = 0; col < dimension - 1; col++) {\n    for (let row = 0; row < dimension; row++) {\n      let nextCol = col + 1;\n\n      if (shifted[row][col] === shifted[row][nextCol]) {\n        merge(shifted, row, col, row, nextCol);\n      }\n    }\n  }\n}\n\nfunction shiftDown(shifted) {\n  for (let row = dimension - 1; row > 0; row--) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextRow = row - 1;\n\n      if (shifted[row][col] === shifted[nextRow][col]) {\n        merge(shifted, row, col, nextRow, col);\n      }\n    }\n  }\n}\n\nfunction shiftRight(shifted) {\n  for (let col = dimension - 1; col > 0; col--) {\n    for (let row = dimension - 1; row > 0; row--) {\n      let nextCol = col - 1;\n\n      if (shifted[row][col] === shifted[row][nextCol]) {\n        merge(shifted, row, col, row, nextCol);\n      }\n    }\n  }\n}\n\nexport function fullMerge(shifted, direction) {\n  switch (direction) {\n    case DIRECTION.UP:\n      shiftUp(shifted);\n      break;\n\n    case DIRECTION.DOWN:\n      shiftDown(shifted);\n      break;\n\n    case DIRECTION.LEFT:\n      shiftLeft(shifted);\n      break;\n\n    case DIRECTION.RIGHT:\n      shiftRight(shifted);\n      break;\n\n    default:\n      console.log('not a direction');\n    //do nothing\n  }\n} // happens in one board update when key pressed\n\nexport function fullShift(tiles, direction) {\n  var shifted = [...tiles];\n  slideWholeBoard(shifted, direction);\n  fullMerge(shifted, direction);\n}\nexport default {\n  merge,\n  slideUp,\n  slideDown,\n  slideWholeBoard,\n  fullMerge,\n  fullShift\n};","map":{"version":3,"sources":["/home/lregina/onboarding/2048/src/board.js"],"names":["dimension","DIRECTION","newNum","tiles","newTiles","slice","row","Math","floor","random","col","getIndex","merge","shifted","row1","col1","row2","col2","currentVal","adjacentVal","slideUp","slideLeft","slideDown","slideRight","slideWholeBoard","direction","UP","DOWN","LEFT","RIGHT","console","log","shiftUp","nextRow","shiftLeft","nextCol","shiftDown","shiftRight","fullMerge","fullShift"],"mappings":"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","sourcesContent":["import { dimension, DIRECTION} from \"./constants.js\"; \n\n// TO DO: detect if no empty tiles left\n// generates new num in random spot and updates board\nfunction newNum(tiles) {\n  let newTiles = tiles.slice();\n  let row = Math.floor(Math.random() * dimension);\n  let col = Math.floor(Math.random() * dimension);\n  if (tiles[row][col] === 0) {\n    newTiles[row][col] = 2;\n  } else {\n    newNum(tiles);\n  }\n  return newTiles;\n}\n\n// return random row or col index\nfunction getIndex() {\n  return Math.floor(Math.random() * dimension);\n}\n\n// side effect: modify shifted\nexport function merge(shifted, row1, col1, row2, col2) {\n\tlet currentVal = shifted[row1][col1];\n\tlet adjacentVal = shifted[row2][col2];\n\tshifted[row1][col1] = currentVal + adjacentVal; \n\tshifted[row2][col2] = 0;\n}\n\n// do \"sliding all the way\" when shift\nexport function slideUp(shifted, col){\n\tfor (let row = 0; row < dimension - 1; row++) {\n\t\tif (shifted[row][col] == 0) {\n\t\t\tlet row2 = row + 1;\n\t\t\twhile (row2 < dimension - 1 && shifted[row2][col] === 0) {\n\t\t\t\trow2 += 1;\n\t\t\t}\n\t\t\tmerge(shifted, row, col, row2, col);\n\t\t}\t\n\t}\n\treturn shifted;\n}\n\nfunction slideLeft(shifted, row) {\n\tfor (let col = 0; col < dimension - 1; col ++) {\n\t\tif (shifted[row][col] == 0) {\n\t\t\tlet col2 = col + 1;\n\t\t\twhile (col2 < dimension - 1 && shifted[row][col2] === 0) {\n\t\t\t\tcol2 += 1;\n\t\t\t}\n\t\t\tmerge(shifted, row, col, row, col2);\n\t\t}\t\n\t}\n\treturn shifted;\n}\n\nfunction slideDown(shifted, col){\n\tfor (let row = dimension - 1; row > 0; row--) {\n\t\tif (shifted[row][col] == 0) {\n\t\t\tlet row2 = row - 1;\n\t\t\twhile (row2 > 0 && shifted[row2][col] === 0) {\n\t\t\t\trow2 -= 1;\n\t\t\t}\n\t\t\tmerge(shifted, row, col, row2, col);\n\t\t}\t\n\t}\n\treturn shifted;\n}\n\nfunction slideRight(shifted, row){\n\tfor (let col = dimension - 1; col > 0; col--) {\n\t\tif (shifted[row][col] == 0) {\n\t\t\tlet col2 = col - 1;\n\t\t\twhile (col2 > 0 && shifted[row][col2] === 0) {\n\t\t\t\tcol2 -= 1;\n\t\t\t}\n\t\t\tmerge(shifted, row, col, row, col2);\n\t\t}\t\n\t}\n\treturn shifted;\n}\n\nexport function slideWholeBoard(shifted, direction) {\n\tfor (let col = 0; col < dimension; col++) {\n\t\tswitch(direction) {\n\t\t\tcase DIRECTION.UP:\n\t\t\t\tslideUp(shifted, col);\t\t\n\t\t\t\tbreak;\n\t\t\tcase DIRECTION.DOWN:\n\t\t\t\tslideDown(shifted, col);\n\t\t\t\tbreak;\n\t\t\tcase DIRECTION.LEFT:\n\t\t\t\tslideLeft(shifted, col);\n\t\t\t\tbreak;\n\t\t\tcase DIRECTION.RIGHT:\n\t\t\t\tslideRight(shifted, col);\n\t\t\t\tbreak;\n\t\t\tdefault: \n\t\t\t\tconsole.log('not a direction');\n\t\t\t\t//do nothing\n\t\t}\n\t}\n}\n\n// modify board with merged tiles shifted up one\nfunction shiftUp(shifted) {\n\tfor (let row = 0; row < dimension - 1; row++) {\n\t\tfor (let col = 0; col < dimension; col++) {\n\t\t\tlet nextRow = row + 1;\n\t\t\tif (shifted[row][col] === shifted[nextRow][col]) {\n\t\t\t\tmerge(shifted, row, col, nextRow, col)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction shiftLeft(shifted) {\n\tfor (let col = 0; col < dimension - 1; col++) {\n\t\tfor (let row = 0; row < dimension; row++) {\n\t\t\tlet nextCol = col + 1;\n\t\t\tif (shifted[row][col] === shifted[row][nextCol]) {\n\t\t\t\tmerge(shifted, row, col, row, nextCol)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction shiftDown(shifted) {\n\tfor (let row = dimension - 1; row > 0; row--) {\n\t\tfor (let col = dimension - 1; col > 0; col--) {\n\t\t\tlet nextRow = row - 1;\n\t\t\tif (shifted[row][col] === shifted[nextRow][col]) {\n\t\t\t\tmerge(shifted, row, col, nextRow, col)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction shiftRight(shifted) {\n\tfor (let col = dimension - 1; col > 0; col--) {\n\t\tfor (let row = dimension - 1; row > 0; row--) {\n\t\t\tlet nextCol = col - 1;\n\t\t\tif (shifted[row][col] === shifted[row][nextCol]) {\n\t\t\t\tmerge(shifted, row, col, row, nextCol)\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function fullMerge(shifted, direction) {\n\tswitch(direction) {\n\t\tcase DIRECTION.UP:\n\t\t\tshiftUp(shifted);\n\t\t\tbreak;\n\t\tcase DIRECTION.DOWN:\n\t\t\tshiftDown(shifted);\n\t\t\tbreak;\n\t\tcase DIRECTION.LEFT:\n\t\t\tshiftLeft(shifted);\n\t\t\tbreak;\n\t\tcase DIRECTION.RIGHT:\n\t\t\tshiftRight(shifted);\n\t\t\tbreak;\n\t\tdefault: \n\t\t\tconsole.log('not a direction');\n\t\t\t//do nothing\n\t}\n}\n\n// happens in one board update when key pressed\nexport function fullShift(tiles, direction) {\n\tvar shifted = [...tiles];\n\tslideWholeBoard(shifted, direction);\n\tfullMerge(shifted, direction);\n}\n\nexport default { \n\tmerge, \n\tslideUp, \n\tslideDown, \n\tslideWholeBoard, \n\tfullMerge,\n\tfullShift \n};\n"]},"metadata":{},"sourceType":"module"}