{"ast":null,"code":"import { dimension, DIRECTION, winningTile } from \"../constants.js\"; //is there a better way of doing this\n\nexport function gameOver(newTiles) {\n  for (let i = 0; i < dimension; i++) {\n    for (let j = 0; j < dimension; j++) {\n      if (newTiles[i][j] === winningTile) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n} // side effect: modify newTiles\n\nconst merge = (newTiles, row1, col1, row2, col2) => {\n  let currentVal = newTiles[row1][col1];\n  let adjacentVal = newTiles[row2][col2];\n  let newVal = currentVal + adjacentVal;\n  newTiles[row1][col1] = currentVal + adjacentVal;\n  newTiles[row2][col2] = 0;\n}; // do \"sliding all the way\" when shift\n\n\nconst slideUp = (newTiles, col) => {\n  //slide incrementally\n  for (let row = 0; row < dimension - 1; row++) {\n    if (newTiles[row][col] === 0) {\n      let row2 = row + 1; //slide next available non blank tile\n\n      while (row2 < dimension - 1 && newTiles[row2][col] === 0) {\n        row2 += 1;\n      }\n\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n\n  return newTiles;\n};\n\nconst slideLeft = (newTiles, row) => {\n  for (let col = 0; col < dimension - 1; col++) {\n    if (newTiles[row][col] === 0) {\n      let col2 = col + 1;\n\n      while (col2 < dimension - 1 && newTiles[row][col2] === 0) {\n        col2 += 1;\n      }\n\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n\n  return newTiles;\n};\n\nconst slideDown = (newTiles, col) => {\n  for (let row = dimension - 1; row > 0; row--) {\n    if (newTiles[row][col] === 0) {\n      let row2 = row - 1;\n\n      while (row2 > 0 && newTiles[row2][col] === 0) {\n        row2 -= 1;\n      }\n\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n\n  return newTiles;\n};\n\nconst slideRight = (newTiles, row) => {\n  for (let col = dimension - 1; col > 0; col--) {\n    if (newTiles[row][col] === 0) {\n      let col2 = col - 1;\n\n      while (col2 > 0 && newTiles[row][col2] === 0) {\n        col2 -= 1;\n      }\n\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n\n  return newTiles;\n};\n\nconst slideWholeBoard = (newTiles, direction) => {\n  for (let col = 0; col < dimension; col++) {\n    switch (direction) {\n      case DIRECTION.UP:\n        slideUp(newTiles, col);\n        break;\n\n      case DIRECTION.DOWN:\n        slideDown(newTiles, col);\n        break;\n\n      case DIRECTION.LEFT:\n        slideLeft(newTiles, col);\n        break;\n\n      case DIRECTION.RIGHT:\n        slideRight(newTiles, col);\n        break;\n\n      default:\n        console.log('not a direction');\n      //do nothing\n    }\n  }\n}; // modify board with merged tiles newTiles up one\n\n\nconst shiftUp = newTiles => {\n  for (let row = 0; row < dimension - 1; row++) {\n    for (let col = 0; col < dimension; col++) {\n      let nextRow = row + 1;\n\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n};\n\nconst shiftLeft = newTiles => {\n  for (let row = 0; row < dimension; row++) {\n    for (let col = 0; col < dimension - 1; col++) {\n      let nextCol = col + 1;\n\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n};\n\nconst shiftDown = newTiles => {\n  for (let row = dimension - 1; row > 0; row--) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextRow = row - 1;\n\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n};\n\nconst shiftRight = newTiles => {\n  for (let row = 0; row < dimension; row++) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextCol = col - 1;\n\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n};\n\nconst fullMerge = (newTiles, direction) => {\n  switch (direction) {\n    case DIRECTION.UP:\n      shiftUp(newTiles);\n      break;\n\n    case DIRECTION.DOWN:\n      shiftDown(newTiles);\n      break;\n\n    case DIRECTION.LEFT:\n      shiftLeft(newTiles);\n      break;\n\n    case DIRECTION.RIGHT:\n      shiftRight(newTiles);\n      break;\n\n    default:\n      console.log('not a direction');\n    //do nothing\n  }\n}; // return random row or col index\n\n\nconst getRandomIndex = () => {\n  return Math.floor(Math.random() * dimension);\n}; // TO DO: detect if no empty tiles left or it will infinitely loop\n// generates new num in random spot and updates board\n\n\nconst generateNewNum = newTiles => {\n  let row = getRandomIndex();\n  let col = getRandomIndex();\n\n  if (newTiles[row][col] === 0) {\n    newTiles[row][col] = 2;\n  } else {\n    generateNewNum(newTiles);\n  }\n}; // keep for testing\n// happens in one board update when key pressed\n\n\nconst fullShift = (newTiles, direction) => {\n  slideWholeBoard(newTiles, direction);\n  fullMerge(newTiles, direction);\n  slideWholeBoard(newTiles, direction);\n  return newTiles;\n};\n\nconst updateTiles = (tiles, direction) => {\n  var newTiles = [...tiles];\n  fullShift(newTiles, direction);\n  generateNewNum(newTiles);\n  return newTiles;\n};\n\nexport default {\n  merge,\n  slideUp,\n  slideDown,\n  slideWholeBoard,\n  fullMerge,\n  fullShift,\n  updateTiles,\n  gameOver\n};","map":{"version":3,"sources":["/home/lregina/onboarding/2048/src/components/board.js"],"names":["dimension","DIRECTION","winningTile","gameOver","newTiles","i","j","merge","row1","col1","row2","col2","currentVal","adjacentVal","newVal","slideUp","col","row","slideLeft","slideDown","slideRight","slideWholeBoard","direction","UP","DOWN","LEFT","RIGHT","console","log","shiftUp","nextRow","shiftLeft","nextCol","shiftDown","shiftRight","fullMerge","getRandomIndex","Math","floor","random","generateNewNum","fullShift","updateTiles","tiles"],"mappings":"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","sourcesContent":["import { dimension, DIRECTION, winningTile} from \"../constants.js\"; \n\n//is there a better way of doing this\nexport function gameOver(newTiles) {\n\tfor (let i = 0; i < dimension; i++)\t{\n\t\tfor (let j = 0; j < dimension; j++) {\n\t\t\tif (newTiles[i][j] === winningTile) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n// side effect: modify newTiles\nconst merge = (newTiles, row1, col1, row2, col2) => {\n\tlet currentVal = newTiles[row1][col1];\n\tlet adjacentVal = newTiles[row2][col2];\n\tlet newVal = currentVal + adjacentVal\n\tnewTiles[row1][col1] = currentVal + adjacentVal; \n\tnewTiles[row2][col2] = 0;\n}\n\n// do \"sliding all the way\" when shift\nconst slideUp = (newTiles, col) => {\n\t//slide incrementally\n\tfor (let row = 0; row < dimension - 1; row++) {\n\t\tif (newTiles[row][col] === 0) {\n\t\t\tlet row2 = row + 1;\n\t\t\t//slide next available non blank tile\n\t\t\twhile (row2 < dimension - 1 && newTiles[row2][col] === 0) {\n\t\t\t\trow2 += 1;\n\t\t\t}\n\t\t\tmerge(newTiles, row, col, row2, col);\n\t\t}\t\n\t}\n\treturn newTiles;\n}\n\nconst slideLeft = (newTiles, row) => {\n\tfor (let col = 0; col < dimension - 1; col ++) {\n\t\tif (newTiles[row][col] === 0) {\n\t\t\tlet col2 = col + 1;\n\t\t\twhile (col2 < dimension - 1 && newTiles[row][col2] === 0) {\n\t\t\t\tcol2 += 1;\n\t\t\t}\n\t\t\tmerge(newTiles, row, col, row, col2);\n\t\t}\t\n\t}\n\treturn newTiles;\n}\n\nconst slideDown = (newTiles, col) => {\n\tfor (let row = dimension - 1; row > 0; row--) {\n\t\tif (newTiles[row][col] === 0) {\n\t\t\tlet row2 = row - 1;\n\t\t\twhile (row2 > 0 && newTiles[row2][col] === 0) {\n\t\t\t\trow2 -= 1;\n\t\t\t}\n\t\t\tmerge(newTiles, row, col, row2, col);\n\t\t}\t\n\t}\n\treturn newTiles;\n}\n\nconst slideRight = (newTiles, row) => {\n\tfor (let col = dimension - 1; col > 0; col--) {\n\t\tif (newTiles[row][col] === 0) {\n\t\t\tlet col2 = col - 1;\n\t\t\twhile (col2 > 0 && newTiles[row][col2] === 0) {\n\t\t\t\tcol2 -= 1;\n\t\t\t}\n\t\t\tmerge(newTiles, row, col, row, col2);\n\t\t}\t\n\t}\n\treturn newTiles;\n}\n\nconst slideWholeBoard = (newTiles, direction) => {\n\tfor (let col = 0; col < dimension; col++) {\n\t\tswitch(direction) {\n\t\t\tcase DIRECTION.UP:\n\t\t\t\tslideUp(newTiles, col);\t\t\n\t\t\t\tbreak;\n\t\t\tcase DIRECTION.DOWN:\n\t\t\t\tslideDown(newTiles, col);\n\t\t\t\tbreak;\n\t\t\tcase DIRECTION.LEFT:\n\t\t\t\tslideLeft(newTiles, col);\n\t\t\t\tbreak;\n\t\t\tcase DIRECTION.RIGHT:\n\t\t\t\tslideRight(newTiles, col);\n\t\t\t\tbreak;\n\t\t\tdefault: \n\t\t\t\tconsole.log('not a direction');\n\t\t\t\t//do nothing\n\t\t}\n\t}\n}\n\n// modify board with merged tiles newTiles up one\nconst shiftUp = (newTiles) => {\n\tfor (let row = 0; row < dimension - 1; row++) {\n\t\tfor (let col = 0; col < dimension; col++) {\n\t\t\tlet nextRow = row + 1;\n\t\t\tif (newTiles[row][col] === newTiles[nextRow][col]) {\n\t\t\t\tmerge(newTiles, row, col, nextRow, col)\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst shiftLeft = (newTiles) => {\n\tfor (let row = 0; row < dimension; row++) {\n\t\tfor (let col = 0; col < dimension - 1; col++) {\n\t\t\tlet nextCol = col + 1;\n\t\t\tif (newTiles[row][col] === newTiles[row][nextCol]) {\n\t\t\t\tmerge(newTiles, row, col, row, nextCol)\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst shiftDown = (newTiles) => {\n\tfor (let row = dimension - 1; row > 0; row--) {\n\t\tfor (let col = dimension - 1; col > 0; col--) {\n\t\t\tlet nextRow = row - 1;\n\t\t\tif (newTiles[row][col] === newTiles[nextRow][col]) {\n\t\t\t\tmerge(newTiles, row, col, nextRow, col)\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst shiftRight = (newTiles) => {\n\tfor (let row = 0; row < dimension; row++) {\n\t\tfor (let col = dimension - 1; col > 0; col--) {\n\t\t\tlet nextCol = col - 1;\n\t\t\tif (newTiles[row][col] === newTiles[row][nextCol]) {\n\t\t\t\tmerge(newTiles, row, col, row, nextCol)\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst fullMerge = (newTiles, direction) => {\n\tswitch(direction) {\n\t\tcase DIRECTION.UP:\n\t\t\tshiftUp(newTiles);\n\t\t\tbreak;\n\t\tcase DIRECTION.DOWN:\n\t\t\tshiftDown(newTiles);\n\t\t\tbreak;\n\t\tcase DIRECTION.LEFT:\n\t\t\tshiftLeft(newTiles);\n\t\t\tbreak;\n\t\tcase DIRECTION.RIGHT:\n\t\t\tshiftRight(newTiles);\n\t\t\tbreak;\n\t\tdefault: \n\t\t\tconsole.log('not a direction');\n\t\t\t//do nothing\n\t}\n}\n\n// return random row or col index\nconst getRandomIndex = () => {\n  return Math.floor(Math.random() * dimension);\n}\n\n// TO DO: detect if no empty tiles left or it will infinitely loop\n// generates new num in random spot and updates board\nconst generateNewNum = (newTiles) => {\n\tlet row = getRandomIndex();\n\tlet col = getRandomIndex();\n  if (newTiles[row][col] === 0) {\n    newTiles[row][col] = 2;\n  } else {\n\t\tgenerateNewNum(newTiles);\n  }\n}\n\n// keep for testing\n// happens in one board update when key pressed\nconst fullShift = (newTiles, direction) => {\n\tslideWholeBoard(newTiles, direction);\n\tfullMerge(newTiles, direction);\n\tslideWholeBoard(newTiles, direction);\n\treturn newTiles;\n}\n\nconst updateTiles = (tiles, direction) => {\n\tvar newTiles = [...tiles];\n\tfullShift(newTiles, direction)\n\tgenerateNewNum(newTiles);\n\treturn newTiles;\n}\n\nexport default { \n\tmerge, \n\tslideUp, \n\tslideDown, \n\tslideWholeBoard, \n\tfullMerge,\n\tfullShift, \n\tupdateTiles,\n\tgameOver,\n};\n"]},"metadata":{},"sourceType":"module"}