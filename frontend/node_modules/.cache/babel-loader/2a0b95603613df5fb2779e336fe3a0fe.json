{"ast":null,"code":"import _slicedToArray from \"/home/lregina/2048/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useContext, useEffect, useState } from \"react\";\nimport { dimension, DIRECTION, winningTile } from \"./constants.js\";\nimport { GameContext, BoardContext } from './index.js';\nimport './style.css';\nexport const GameLogic = () => {\n  const _useContext = useContext(GameContext),\n        gameOver = _useContext.gameOver,\n        setGameOver = _useContext.setGameOver,\n        gameWon = _useContext.gameWon,\n        setGameWon = _useContext.setGameWon,\n        pressed = _useContext.pressed;\n\n  const _useContext2 = useContext(BoardContext),\n        tiles = _useContext2.tiles,\n        setTiles = _useContext2.setTiles;\n\n  const _useState = useState(0),\n        _useState2 = _slicedToArray(_useState, 2),\n        biggestTile = _useState2[0],\n        setBiggestTile = _useState2[1];\n\n  const _useState3 = useState(dimension * dimension),\n        _useState4 = _slicedToArray(_useState3, 2),\n        numEmptyTiles = _useState4[0],\n        setNumEmptyTiles = _useState4[1];\n  /**\n   * Handle board updates in one move\n   */\n\n\n  const move = () => {\n    var direction = pressed.direction;\n\n    if (direction != null) {\n      var newTiles = updateTiles(tiles, direction);\n      setTiles(newTiles);\n    }\n  };\n\n  useEffect(() => {\n    if (!gameOver) {\n      move();\n    }\n  }, [pressed]);\n  /**\n   * Update board tiles in specified direction\n   * @param {DIRECTION} direction to shift board\n   */\n\n  const updateTiles = (tiles, direction) => {\n    var newTiles = [...tiles];\n    shift(newTiles, direction);\n    generateNewNum(newTiles);\n    return newTiles;\n  };\n  /**\n   * Full shift in direction specified\n   */\n\n\n  const shift = (newTiles, direction) => {\n    for (let pass = 0; pass < dimension; pass++) {\n      switch (direction) {\n        case DIRECTION.UP:\n          shiftUp(newTiles);\n          break;\n\n        case DIRECTION.DOWN:\n          shiftDown(newTiles);\n          break;\n\n        case DIRECTION.LEFT:\n          shiftLeft(newTiles);\n          break;\n\n        case DIRECTION.RIGHT:\n          shiftRight(newTiles);\n          break;\n\n        default:\n          console.log(\"not a direction\");\n      }\n    }\n  };\n  /*\n   * Each tile shifts up one space if possible\n   */\n\n\n  const shiftUp = newTiles => {\n    for (let row = 0; row < dimension - 1; row++) {\n      for (let col = 0; col < dimension; col++) {\n        let nextRow = row + 1;\n        let nextCol = col;\n\n        if (canMerge(newTiles, row, col, nextRow, nextCol)) {\n          merge(newTiles, row, col, nextRow, nextCol);\n        }\n      }\n    }\n  };\n  /*\n   * Each tile shifts left one if possible\n   */\n\n\n  const shiftLeft = newTiles => {\n    for (let row = 0; row < dimension; row++) {\n      for (let col = 0; col < dimension - 1; col++) {\n        let nextRow = row;\n        let nextCol = col + 1;\n\n        if (canMerge(newTiles, row, col, nextRow, nextCol)) {\n          merge(newTiles, row, col, nextRow, nextCol);\n        }\n      }\n    }\n  };\n  /*\n   * Each tile shifts down one if possible\n   */\n\n\n  const shiftDown = newTiles => {\n    for (let row = dimension - 1; row > 0; row--) {\n      for (let col = 0; col < dimension; col++) {\n        let nextRow = row - 1;\n        let nextCol = col;\n\n        if (canMerge(newTiles, row, col, nextRow, nextCol)) {\n          merge(newTiles, row, col, nextRow, nextCol);\n        }\n      }\n    }\n  };\n  /*\n   * Each tile shifts right one if possible\n   */\n\n\n  const shiftRight = newTiles => {\n    for (let row = 0; row < dimension; row++) {\n      for (let col = dimension - 1; col > 0; col--) {\n        let nextRow = row;\n        let nextCol = col - 1;\n\n        if (canMerge(newTiles, row, col, nextRow, nextCol)) {\n          merge(newTiles, row, col, nextRow, nextCol);\n        }\n      }\n    }\n  };\n  /**\n   * Sum value from nextRow, nextCol, into row, col \n   * Side effect: if new value formed is winning Tile, set game over\n   */\n\n\n  const merge = (newTiles, row, col, nextRow, nextCol) => {\n    if (newTiles[row][col] !== 0) {\n      //not merging into empty\n      setNumEmptyTiles(numEmptyTiles => numEmptyTiles + 1);\n    }\n\n    let newVal = newTiles[row][col] + newTiles[nextRow][nextCol];\n    newTiles[row][col] = newVal;\n    newTiles[nextRow][nextCol] = 0;\n\n    if (newVal > biggestTile) {\n      setBiggestTile(newVal);\n\n      if (newVal === winningTile) {\n        setGameWon(true);\n        setGameOver(true);\n      }\n    }\n\n    return newVal;\n  };\n  /**\n   * We can merge if tiles match or if merging into a blank\n   */\n\n\n  const canMerge = (newTiles, row, col, nextRow, nextCol) => {\n    return newTiles[row][col] === newTiles[nextRow][nextCol] || newTiles[row][col] === 0;\n  };\n  /** \n   * return random row or col index\n   */\n\n\n  const getRandomIndex = () => {\n    return Math.floor(Math.random() * dimension);\n  };\n  /**\n   * Generates new 2 or 4 in random spot and updates board\n   */\n\n\n  const generateNewNum = newTiles => {\n    let row = getRandomIndex();\n    let col = getRandomIndex();\n\n    if (newTiles[row][col] === 0) {\n      newTiles[row][col] = numToGenerate();\n      setNumEmptyTiles(numEmptyTiles => numEmptyTiles - 1);\n    } else {\n      if (numEmptyTiles !== 0) {\n        generateNewNum(newTiles);\n      } else {\n        setGameOver(true);\n        setGameWon(false);\n      }\n    }\n  };\n  /**\n   * when we reach a high enough point, generate 4\n   */\n\n\n  const numToGenerate = () => {\n    if (biggestTile >= 64) {\n      if (Math.random() > .5) {\n        return 4;\n      }\n    }\n\n    return 2;\n  };\n\n  return gameWon;\n};","map":{"version":3,"sources":["/home/lregina/2048/frontend/src/gameLogic.js"],"names":["useContext","useEffect","useState","dimension","DIRECTION","winningTile","GameContext","BoardContext","GameLogic","gameOver","setGameOver","gameWon","setGameWon","pressed","tiles","setTiles","biggestTile","setBiggestTile","numEmptyTiles","setNumEmptyTiles","move","direction","newTiles","updateTiles","shift","generateNewNum","pass","UP","shiftUp","DOWN","shiftDown","LEFT","shiftLeft","RIGHT","shiftRight","console","log","row","col","nextRow","nextCol","canMerge","merge","newVal","getRandomIndex","Math","floor","random","numToGenerate"],"mappings":";AAAA,SAASA,UAAT,EAAqBC,SAArB,EAAgCC,QAAhC,QAAgD,OAAhD;AACA,SAASC,SAAT,EAAoBC,SAApB,EAA+BC,WAA/B,QAAkD,gBAAlD;AACA,SAASC,WAAT,EAAsBC,YAAtB,QAA0C,YAA1C;AACA,OAAO,aAAP;AAEA,OAAO,MAAMC,SAAS,GAAG,MAAO;AAAA,sBAO3BR,UAAU,CAACM,WAAD,CAPiB;AAAA,QAE9BG,QAF8B,eAE9BA,QAF8B;AAAA,QAG9BC,WAH8B,eAG9BA,WAH8B;AAAA,QAI9BC,OAJ8B,eAI9BA,OAJ8B;AAAA,QAK9BC,UAL8B,eAK9BA,UAL8B;AAAA,QAM9BC,OAN8B,eAM9BA,OAN8B;;AAAA,uBAQHb,UAAU,CAACO,YAAD,CARP;AAAA,QAQvBO,KARuB,gBAQvBA,KARuB;AAAA,QAQhBC,QARgB,gBAQhBA,QARgB;;AAAA,oBASSb,QAAQ,CAAC,CAAD,CATjB;AAAA;AAAA,QASvBc,WATuB;AAAA,QASVC,cATU;;AAAA,qBAUaf,QAAQ,CAACC,SAAS,GAAGA,SAAb,CAVrB;AAAA;AAAA,QAUvBe,aAVuB;AAAA,QAURC,gBAVQ;AAY/B;;;;;AAGC,QAAMC,IAAI,GAAG,MAAM;AACjB,QAAIC,SAAS,GAAGR,OAAO,CAACQ,SAAxB;;AACA,QAAIA,SAAS,IAAI,IAAjB,EAAuB;AACrB,UAAIC,QAAQ,GAAGC,WAAW,CAACT,KAAD,EAAQO,SAAR,CAA1B;AACAN,MAAAA,QAAQ,CAACO,QAAD,CAAR;AACD;AACF,GAND;;AAOArB,EAAAA,SAAS,CAAC,MAAM;AAChB,QAAI,CAACQ,QAAL,EAAe;AACdW,MAAAA,IAAI;AACJ;AACA,GAJQ,EAIN,CAACP,OAAD,CAJM,CAAT;AAMD;;;;;AAIA,QAAMU,WAAW,GAAG,CAACT,KAAD,EAAQO,SAAR,KAAsB;AACzC,QAAIC,QAAQ,GAAG,CAAC,GAAGR,KAAJ,CAAf;AACAU,IAAAA,KAAK,CAACF,QAAD,EAAWD,SAAX,CAAL;AACAI,IAAAA,cAAc,CAACH,QAAD,CAAd;AACA,WAAOA,QAAP;AACA,GALD;AAOA;;;;;AAGA,QAAME,KAAK,GAAG,CAACF,QAAD,EAAWD,SAAX,KAAyB;AACtC,SAAK,IAAIK,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGvB,SAA1B,EAAqCuB,IAAI,EAAzC,EAA6C;AAC5C,cAAQL,SAAR;AACC,aAAKjB,SAAS,CAACuB,EAAf;AACCC,UAAAA,OAAO,CAACN,QAAD,CAAP;AACA;;AACD,aAAKlB,SAAS,CAACyB,IAAf;AACCC,UAAAA,SAAS,CAACR,QAAD,CAAT;AACA;;AACD,aAAKlB,SAAS,CAAC2B,IAAf;AACCC,UAAAA,SAAS,CAACV,QAAD,CAAT;AACA;;AACD,aAAKlB,SAAS,CAAC6B,KAAf;AACCC,UAAAA,UAAU,CAACZ,QAAD,CAAV;AACA;;AACD;AACCa,UAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AAdF;AAgBA;AACD,GAnBD;AAqBA;;;;;AAGA,QAAMR,OAAO,GAAGN,QAAQ,IAAI;AAC3B,SAAK,IAAIe,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGlC,SAAS,GAAG,CAApC,EAAuCkC,GAAG,EAA1C,EAA8C;AAC7C,WAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGnC,SAAxB,EAAmCmC,GAAG,EAAtC,EAA0C;AACzC,YAAIC,OAAO,GAAGF,GAAG,GAAG,CAApB;AACA,YAAIG,OAAO,GAAGF,GAAd;;AACA,YAAIG,QAAQ,CAACnB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,CAAZ,EAAoD;AACnDE,UAAAA,KAAK,CAACpB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,CAAL;AACA;AACD;AACD;AACD,GAVD;AAYA;;;;;AAGA,QAAMR,SAAS,GAAGV,QAAQ,IAAI;AAC7B,SAAK,IAAIe,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGlC,SAAxB,EAAmCkC,GAAG,EAAtC,EAA0C;AACzC,WAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGnC,SAAS,GAAG,CAApC,EAAuCmC,GAAG,EAA1C,EAA8C;AAC7C,YAAIC,OAAO,GAAGF,GAAd;AACA,YAAIG,OAAO,GAAGF,GAAG,GAAG,CAApB;;AACA,YAAIG,QAAQ,CAACnB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,CAAZ,EAAoD;AACnDE,UAAAA,KAAK,CAACpB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,CAAL;AACA;AACD;AACD;AACD,GAVD;AAYA;;;;;AAGA,QAAMV,SAAS,GAAGR,QAAQ,IAAI;AAC7B,SAAK,IAAIe,GAAG,GAAGlC,SAAS,GAAG,CAA3B,EAA8BkC,GAAG,GAAG,CAApC,EAAuCA,GAAG,EAA1C,EAA8C;AAC7C,WAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGnC,SAAxB,EAAmCmC,GAAG,EAAtC,EAA0C;AACzC,YAAIC,OAAO,GAAGF,GAAG,GAAG,CAApB;AACA,YAAIG,OAAO,GAAGF,GAAd;;AACA,YAAIG,QAAQ,CAACnB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,CAAZ,EAAoD;AACnDE,UAAAA,KAAK,CAACpB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,CAAL;AACA;AACD;AACD;AACD,GAVD;AAYA;;;;;AAGA,QAAMN,UAAU,GAAGZ,QAAQ,IAAI;AAC9B,SAAK,IAAIe,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGlC,SAAxB,EAAmCkC,GAAG,EAAtC,EAA0C;AACzC,WAAK,IAAIC,GAAG,GAAGnC,SAAS,GAAG,CAA3B,EAA8BmC,GAAG,GAAG,CAApC,EAAuCA,GAAG,EAA1C,EAA8C;AAC7C,YAAIC,OAAO,GAAGF,GAAd;AACA,YAAIG,OAAO,GAAGF,GAAG,GAAG,CAApB;;AACA,YAAIG,QAAQ,CAACnB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,CAAZ,EAAoD;AACnDE,UAAAA,KAAK,CAACpB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,CAAL;AACA;AACD;AACD;AACD,GAVD;AAaA;;;;;;AAIA,QAAME,KAAK,GAAG,CAACpB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,KAA0C;AACvD,QAAIlB,QAAQ,CAACe,GAAD,CAAR,CAAcC,GAAd,MAAuB,CAA3B,EAA8B;AAAE;AAC/BnB,MAAAA,gBAAgB,CAACD,aAAa,IAAIA,aAAa,GAAG,CAAlC,CAAhB;AACA;;AACD,QAAIyB,MAAM,GAAGrB,QAAQ,CAACe,GAAD,CAAR,CAAcC,GAAd,IAAqBhB,QAAQ,CAACiB,OAAD,CAAR,CAAkBC,OAAlB,CAAlC;AACAlB,IAAAA,QAAQ,CAACe,GAAD,CAAR,CAAcC,GAAd,IAAqBK,MAArB;AACArB,IAAAA,QAAQ,CAACiB,OAAD,CAAR,CAAkBC,OAAlB,IAA6B,CAA7B;;AACA,QAAIG,MAAM,GAAG3B,WAAb,EAA0B;AACzBC,MAAAA,cAAc,CAAC0B,MAAD,CAAd;;AACA,UAAIA,MAAM,KAAKtC,WAAf,EAA4B;AAC1BO,QAAAA,UAAU,CAAC,IAAD,CAAV;AACAF,QAAAA,WAAW,CAAC,IAAD,CAAX;AACD;AACD;;AACD,WAAOiC,MAAP;AACA,GAfD;AAiBA;;;;;AAGA,QAAMF,QAAQ,GAAG,CAACnB,QAAD,EAAWe,GAAX,EAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,OAA9B,KAA0C;AAC1D,WAAQlB,QAAQ,CAACe,GAAD,CAAR,CAAcC,GAAd,MAAuBhB,QAAQ,CAACiB,OAAD,CAAR,CAAkBC,OAAlB,CAAvB,IACJlB,QAAQ,CAACe,GAAD,CAAR,CAAcC,GAAd,MAAuB,CAD3B;AAEA,GAHD;AAKA;;;;;AAGA,QAAMM,cAAc,GAAG,MAAM;AAC5B,WAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB5C,SAA3B,CAAP;AACA,GAFD;AAIA;;;;;AAGA,QAAMsB,cAAc,GAAGH,QAAQ,IAAI;AAClC,QAAIe,GAAG,GAAGO,cAAc,EAAxB;AACA,QAAIN,GAAG,GAAGM,cAAc,EAAxB;;AACA,QAAItB,QAAQ,CAACe,GAAD,CAAR,CAAcC,GAAd,MAAuB,CAA3B,EAA8B;AAC7BhB,MAAAA,QAAQ,CAACe,GAAD,CAAR,CAAcC,GAAd,IAAqBU,aAAa,EAAlC;AACA7B,MAAAA,gBAAgB,CAACD,aAAa,IAAIA,aAAa,GAAG,CAAlC,CAAhB;AACA,KAHD,MAGO;AACN,UAAIA,aAAa,KAAK,CAAtB,EAAyB;AACxBO,QAAAA,cAAc,CAACH,QAAD,CAAd;AACA,OAFD,MAEO;AACNZ,QAAAA,WAAW,CAAC,IAAD,CAAX;AACAE,QAAAA,UAAU,CAAC,KAAD,CAAV;AACA;AACD;AACD,GAdD;AAgBA;;;;;AAGA,QAAMoC,aAAa,GAAG,MAAM;AAC3B,QAAIhC,WAAW,IAAI,EAAnB,EAAuB;AACtB,UAAI6B,IAAI,CAACE,MAAL,KAAgB,EAApB,EAAwB;AACvB,eAAO,CAAP;AACA;AACD;;AACD,WAAO,CAAP;AACA,GAPD;;AAQA,SAAOpC,OAAP;AACA,CA/LM","sourcesContent":["import { useContext, useEffect, useState } from \"react\";\nimport { dimension, DIRECTION, winningTile } from \"./constants.js\";\nimport { GameContext, BoardContext } from './index.js'\nimport './style.css'\n\nexport const GameLogic = () =>  {\n\tconst { \n\t\tgameOver, \n\t\tsetGameOver, \n\t\tgameWon, \n\t\tsetGameWon, \n\t\tpressed \n\t} = useContext(GameContext);\n\tconst { tiles, setTiles } = useContext(BoardContext);\n\tconst [ biggestTile, setBiggestTile ] = useState(0);\n\tconst [ numEmptyTiles, setNumEmptyTiles ] = useState(dimension * dimension);\n\t\n\t/**\n\t * Handle board updates in one move\n\t */\n  const move = () => {\n    var direction = pressed.direction;\n    if (direction != null) {\n      var newTiles = updateTiles(tiles, direction);\n      setTiles(newTiles);\n    }\n  };\n  useEffect(() => {\n\t\tif (!gameOver) {\n\t\t\tmove();\n\t\t}\n  }, [pressed]);\n\n\t/**\n\t * Update board tiles in specified direction\n\t * @param {DIRECTION} direction to shift board\n\t */\n\tconst updateTiles = (tiles, direction) => {\n\t\tvar newTiles = [...tiles];\n\t\tshift(newTiles, direction);\n\t\tgenerateNewNum(newTiles);\n\t\treturn newTiles;\n\t};\n\n\t/**\n\t * Full shift in direction specified\n\t */\n\tconst shift = (newTiles, direction) => {\n\t\tfor (let pass = 0; pass < dimension; pass++) {\n\t\t\tswitch (direction) {\n\t\t\t\tcase DIRECTION.UP:\n\t\t\t\t\tshiftUp(newTiles);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTION.DOWN:\n\t\t\t\t\tshiftDown(newTiles);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTION.LEFT:\n\t\t\t\t\tshiftLeft(newTiles);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTION.RIGHT:\n\t\t\t\t\tshiftRight(newTiles);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(\"not a direction\");\n\t\t\t}\n\t\t}\n\t};\n\n\t/*\n\t * Each tile shifts up one space if possible\n\t */\n\tconst shiftUp = newTiles => {\n\t\tfor (let row = 0; row < dimension - 1; row++) {\n\t\t\tfor (let col = 0; col < dimension; col++) {\n\t\t\t\tlet nextRow = row + 1;\n\t\t\t\tlet nextCol = col;\n\t\t\t\tif (canMerge(newTiles, row, col, nextRow, nextCol)) {\n\t\t\t\t\tmerge(newTiles, row, col, nextRow, nextCol);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/*\n\t * Each tile shifts left one if possible\n\t */\n\tconst shiftLeft = newTiles => {\n\t\tfor (let row = 0; row < dimension; row++) {\n\t\t\tfor (let col = 0; col < dimension - 1; col++) {\n\t\t\t\tlet nextRow = row;\n\t\t\t\tlet nextCol = col + 1;\n\t\t\t\tif (canMerge(newTiles, row, col, nextRow, nextCol)) {\n\t\t\t\t\tmerge(newTiles, row, col, nextRow, nextCol);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/*\n\t * Each tile shifts down one if possible\n\t */\n\tconst shiftDown = newTiles => {\n\t\tfor (let row = dimension - 1; row > 0; row--) {\n\t\t\tfor (let col = 0; col < dimension; col++) {\n\t\t\t\tlet nextRow = row - 1;\n\t\t\t\tlet nextCol = col;\n\t\t\t\tif (canMerge(newTiles, row, col, nextRow, nextCol)) {\n\t\t\t\t\tmerge(newTiles, row, col, nextRow, nextCol);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/*\n\t * Each tile shifts right one if possible\n\t */\n\tconst shiftRight = newTiles => {\n\t\tfor (let row = 0; row < dimension; row++) {\n\t\t\tfor (let col = dimension - 1; col > 0; col--) {\n\t\t\t\tlet nextRow = row;\n\t\t\t\tlet nextCol = col - 1;\n\t\t\t\tif (canMerge(newTiles, row, col, nextRow, nextCol)) {\n\t\t\t\t\tmerge(newTiles, row, col, nextRow, nextCol);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\n\t/**\n\t * Sum value from nextRow, nextCol, into row, col \n\t * Side effect: if new value formed is winning Tile, set game over\n\t */\n\tconst merge = (newTiles, row, col, nextRow, nextCol) => {\n\t\tif (newTiles[row][col] !== 0) { //not merging into empty\n\t\t\tsetNumEmptyTiles(numEmptyTiles => numEmptyTiles + 1);\n\t\t}\n\t\tlet newVal = newTiles[row][col] + newTiles[nextRow][nextCol];\n\t\tnewTiles[row][col] = newVal;\n\t\tnewTiles[nextRow][nextCol] = 0;\n\t\tif (newVal > biggestTile) {\n\t\t\tsetBiggestTile(newVal);\n\t\t\tif (newVal === winningTile) {\n\t\t\t\t\tsetGameWon(true);\n\t\t\t\t\tsetGameOver(true);\n\t\t\t}\n\t\t}\n\t\treturn newVal;\n\t};\n\n\t/**\n\t * We can merge if tiles match or if merging into a blank\n\t */\n\tconst canMerge = (newTiles, row, col, nextRow, nextCol) => {\n\t\treturn (newTiles[row][col] === newTiles[nextRow][nextCol] ||\n\t\t\t\t\t\tnewTiles[row][col] === 0);\n\t}\n\n\t/** \n\t * return random row or col index\n\t */\n\tconst getRandomIndex = () => {\n\t\treturn Math.floor(Math.random() * dimension);\n\t};\n\n\t/**\n\t * Generates new 2 or 4 in random spot and updates board\n\t */\n\tconst generateNewNum = newTiles => {\n\t\tlet row = getRandomIndex();\n\t\tlet col = getRandomIndex();\n\t\tif (newTiles[row][col] === 0) {\n\t\t\tnewTiles[row][col] = numToGenerate();\n\t\t\tsetNumEmptyTiles(numEmptyTiles => numEmptyTiles - 1);\n\t\t} else {\n\t\t\tif (numEmptyTiles !== 0) {\n\t\t\t\tgenerateNewNum(newTiles);\n\t\t\t} else {\n\t\t\t\tsetGameOver(true);\n\t\t\t\tsetGameWon(false);\n\t\t\t} \n\t\t}\n\t};\n\n\t/**\n\t * when we reach a high enough point, generate 4\n\t */\n\tconst numToGenerate = () => {\n\t\tif (biggestTile >= 64) {\n\t\t\tif (Math.random() > .5) {\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t}\n\t\treturn 2;\n\t}\n\treturn gameWon; \n}\n"]},"metadata":{},"sourceType":"module"}