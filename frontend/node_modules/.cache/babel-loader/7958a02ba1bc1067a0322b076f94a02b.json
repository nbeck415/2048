{"ast":null,"code":"import _slicedToArray from \"/home/lregina/onboarding/2048/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/home/lregina/onboarding/2048/src/components/board.js\";\nimport React, { createContext, useState, useEffect } from \"react\";\nimport { dimension, DIRECTION, winningTile } from \"../constants.js\";\nimport Tile from \"./Tile.js\";\nimport { StatusBar, GameEndStatus, GameEndDisplay } from \"./GameStatus.js\"; // key press handler using vim keys\n\nconst useKeyPress = () => {\n  const _useState = useState({\n    direction: null\n  }),\n        _useState2 = _slicedToArray(_useState, 2),\n        keyPressed = _useState2[0],\n        setKeyPressed = _useState2[1];\n\n  const downHandler = ({\n    key\n  }) => {\n    let pressed = null;\n\n    switch (key) {\n      case \"k\":\n        pressed = DIRECTION.UP;\n        break;\n\n      case \"j\":\n        pressed = DIRECTION.DOWN;\n        break;\n\n      case \"h\":\n        pressed = DIRECTION.LEFT;\n        break;\n\n      case \"l\":\n        pressed = DIRECTION.RIGHT;\n        break;\n\n      default:\n        pressed = null;\n        break;\n    }\n\n    setKeyPressed({\n      direction: pressed\n    });\n    console.log(\"pressed \".concat(pressed));\n  }; // Add event listeners\n\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", downHandler);\n    return () => {\n      window.removeEventListener(\"keydown\", downHandler);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return keyPressed;\n};\n\nconst Board = () => {\n  let initialTiles = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];\n\n  const _useState3 = useState(initialTiles),\n        _useState4 = _slicedToArray(_useState3, 2),\n        tiles = _useState4[0],\n        setTiles = _useState4[1];\n\n  const _useState5 = useState(false),\n        _useState6 = _slicedToArray(_useState5, 2),\n        gameEnd = _useState6[0],\n        setGameEnd = _useState6[1];\n\n  const pressed = useKeyPress();\n\n  const renderTile = (i, j) => {\n    return React.createElement(Tile, {\n      value: tiles[i][j],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 51\n      },\n      __self: this\n    });\n  };\n\n  const renderStatus = () => {\n    return React.createElement(StatusBar, {\n      gameEnd: gameEnd,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 54\n      },\n      __self: this\n    });\n  };\n\n  const renderRow = i => {\n    return React.createElement(\"div\", {\n      className: \"board-row\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 58\n      },\n      __self: this\n    }, renderTile(i, 0), renderTile(i, 1), renderTile(i, 2), renderTile(i, 3));\n  };\n\n  const renderDisplay = () => {\n    if (gameEnd) {\n      return React.createElement(GameEndDisplay, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 68\n        },\n        __self: this\n      });\n    }\n\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 71\n      },\n      __self: this\n    }, renderRow(0), renderRow(1), renderRow(2), renderRow(3));\n  };\n\n  const updateBoard = () => {\n    var direction = pressed.direction;\n\n    if (direction != null) {\n      // if valid key pressed\n      var newTiles = updateTiles(tiles, direction);\n      setTiles(newTiles);\n      setGameEnd(gameOver(tiles));\n    }\n  };\n\n  useEffect(() => {\n    updateBoard();\n  }, [pressed]);\n  return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92\n    },\n    __self: this\n  }, renderStatus(), renderDisplay());\n}; //is there a better way of doing this\n\n\nconst gameOver = newTiles => {\n  for (let i = 0; i < dimension; i++) {\n    for (let j = 0; j < dimension; j++) {\n      if (newTiles[i][j] === winningTile) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // side effect: modify newTiles\n\n\nconst merge = (newTiles, row1, col1, row2, col2) => {\n  let currentVal = newTiles[row1][col1];\n  let adjacentVal = newTiles[row2][col2];\n  let newVal = currentVal + adjacentVal;\n  newTiles[row1][col1] = currentVal + adjacentVal;\n  newTiles[row2][col2] = 0;\n}; // do \"sliding all the way\" when shift\n\n\nconst slideUp = (newTiles, col) => {\n  //slide incrementally\n  for (let row = 0; row < dimension - 1; row++) {\n    if (newTiles[row][col] === 0) {\n      let row2 = row + 1; //slide next available non blank tile\n\n      while (row2 < dimension - 1 && newTiles[row2][col] === 0) {\n        row2 += 1;\n      }\n\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n\n  return newTiles;\n};\n\nconst slideLeft = (newTiles, row) => {\n  for (let col = 0; col < dimension - 1; col++) {\n    if (newTiles[row][col] === 0) {\n      let col2 = col + 1;\n\n      while (col2 < dimension - 1 && newTiles[row][col2] === 0) {\n        col2 += 1;\n      }\n\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n\n  return newTiles;\n};\n\nconst slideDown = (newTiles, col) => {\n  for (let row = dimension - 1; row > 0; row--) {\n    if (newTiles[row][col] === 0) {\n      let row2 = row - 1;\n\n      while (row2 > 0 && newTiles[row2][col] === 0) {\n        row2 -= 1;\n      }\n\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n\n  return newTiles;\n};\n\nconst slideRight = (newTiles, row) => {\n  for (let col = dimension - 1; col > 0; col--) {\n    if (newTiles[row][col] === 0) {\n      let col2 = col - 1;\n\n      while (col2 > 0 && newTiles[row][col2] === 0) {\n        col2 -= 1;\n      }\n\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n\n  return newTiles;\n};\n\nconst slideWholeBoard = (newTiles, direction) => {\n  for (let col = 0; col < dimension; col++) {\n    switch (direction) {\n      case DIRECTION.UP:\n        slideUp(newTiles, col);\n        break;\n\n      case DIRECTION.DOWN:\n        slideDown(newTiles, col);\n        break;\n\n      case DIRECTION.LEFT:\n        slideLeft(newTiles, col);\n        break;\n\n      case DIRECTION.RIGHT:\n        slideRight(newTiles, col);\n        break;\n\n      default:\n        console.log(\"not a direction\");\n      //do nothing\n    }\n  }\n}; // modify board with merged tiles newTiles up one\n\n\nconst shiftUp = newTiles => {\n  for (let row = 0; row < dimension - 1; row++) {\n    for (let col = 0; col < dimension; col++) {\n      let nextRow = row + 1;\n\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n};\n\nconst shiftLeft = newTiles => {\n  for (let row = 0; row < dimension; row++) {\n    for (let col = 0; col < dimension - 1; col++) {\n      let nextCol = col + 1;\n\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n};\n\nconst shiftDown = newTiles => {\n  for (let row = dimension - 1; row > 0; row--) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextRow = row - 1;\n\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n};\n\nconst shiftRight = newTiles => {\n  for (let row = 0; row < dimension; row++) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextCol = col - 1;\n\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n};\n\nconst fullMerge = (newTiles, direction) => {\n  switch (direction) {\n    case DIRECTION.UP:\n      shiftUp(newTiles);\n      break;\n\n    case DIRECTION.DOWN:\n      shiftDown(newTiles);\n      break;\n\n    case DIRECTION.LEFT:\n      shiftLeft(newTiles);\n      break;\n\n    case DIRECTION.RIGHT:\n      shiftRight(newTiles);\n      break;\n\n    default:\n      console.log(\"not a direction\");\n    //do nothing\n  }\n}; // return random row or col index\n\n\nconst getRandomIndex = () => {\n  return Math.floor(Math.random() * dimension);\n}; // TO DO: detect if no empty tiles left or it will infinitely loop\n// generates new num in random spot and updates board\n\n\nconst generateNewNum = newTiles => {\n  let row = getRandomIndex();\n  let col = getRandomIndex();\n\n  if (newTiles[row][col] === 0) {\n    newTiles[row][col] = 2;\n  } else {\n    generateNewNum(newTiles);\n  }\n}; // keep for testing\n// happens in one board update when key pressed\n\n\nconst fullShift = (newTiles, direction) => {\n  slideWholeBoard(newTiles, direction);\n  fullMerge(newTiles, direction);\n  slideWholeBoard(newTiles, direction);\n  return newTiles;\n};\n\nconst updateTiles = (tiles, direction) => {\n  var newTiles = [...tiles];\n  fullShift(newTiles, direction);\n  generateNewNum(newTiles);\n  return newTiles;\n};\n\nexport { Board, merge, slideUp, slideDown, slideWholeBoard, fullMerge, fullShift, updateTiles, gameOver };","map":{"version":3,"sources":["/home/lregina/onboarding/2048/src/components/board.js"],"names":["React","createContext","useState","useEffect","dimension","DIRECTION","winningTile","Tile","StatusBar","GameEndStatus","GameEndDisplay","useKeyPress","direction","keyPressed","setKeyPressed","downHandler","key","pressed","UP","DOWN","LEFT","RIGHT","console","log","window","addEventListener","removeEventListener","Board","initialTiles","tiles","setTiles","gameEnd","setGameEnd","renderTile","i","j","renderStatus","renderRow","renderDisplay","updateBoard","newTiles","updateTiles","gameOver","merge","row1","col1","row2","col2","currentVal","adjacentVal","newVal","slideUp","col","row","slideLeft","slideDown","slideRight","slideWholeBoard","shiftUp","nextRow","shiftLeft","nextCol","shiftDown","shiftRight","fullMerge","getRandomIndex","Math","floor","random","generateNewNum","fullShift"],"mappings":"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","sourcesContent":["import React, { createContext, useState, useEffect } from \"react\";\nimport { dimension, DIRECTION, winningTile } from \"../constants.js\";\nimport Tile from \"./Tile.js\"\nimport { StatusBar, GameEndStatus, GameEndDisplay } from \"./GameStatus.js\"\n\n// key press handler using vim keys\nconst useKeyPress = () => {\n  const [keyPressed, setKeyPressed] = useState({direction: null});\n\n  const downHandler = ({ key }) => {\n    let pressed = null;\n    switch (key) {\n      case \"k\":\n        pressed = DIRECTION.UP;\n        break;\n      case \"j\":\n        pressed = DIRECTION.DOWN;\n        break;\n      case \"h\":\n        pressed = DIRECTION.LEFT;\n        break;\n      case \"l\":\n        pressed = DIRECTION.RIGHT;\n        break;\n      default:\n        pressed = null;\n        break;\n    }\n    setKeyPressed({direction: pressed});\n    console.log(`pressed ${pressed}`);\n  }\n\n  // Add event listeners\n  useEffect(() => {\n    window.addEventListener(\"keydown\", downHandler);\n\n    return () => {\n      window.removeEventListener(\"keydown\", downHandler);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return keyPressed;\n}\nconst Board = () => {\n  let initialTiles = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];\n  const [tiles, setTiles] = useState(initialTiles);\n\tconst [gameEnd, setGameEnd] = useState(false);\n  const pressed = useKeyPress();\n\n  const renderTile = (i, j) => {\n    return <Tile value={tiles[i][j]}/>;\n  }\n\tconst renderStatus = () => {\n\t\treturn <StatusBar gameEnd={gameEnd}/>\n\t}\n  const renderRow = (i) => {\n    return (\n      <div className=\"board-row\">\n        {renderTile(i, 0)}\n        {renderTile(i, 1)}\n        {renderTile(i, 2)}\n        {renderTile(i, 3)}\n      </div>\n    );\n  }\n\tconst renderDisplay = () => {\n\t\tif (gameEnd) {\n\t\t\treturn <GameEndDisplay />;\n\t\t}\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t{renderRow(0)}\n\t\t\t\t{renderRow(1)}\n\t\t\t\t{renderRow(2)}\n\t\t\t\t{renderRow(3)}\n\t\t\t</div>\n\t\t);\n\t}\n  const updateBoard = () => {\n\t\tvar direction = pressed.direction;\n\t\tif (direction != null) { // if valid key pressed\n\t\t\tvar newTiles = updateTiles(tiles, direction);\n\t\t\tsetTiles(newTiles);\t\n\t\t\tsetGameEnd(gameOver(tiles));\n\t\t}\n  }\n  useEffect(() => {\n\t\tupdateBoard();\n  }, [pressed]);\n\n  return (\n    <div>\n\t\t\t{renderStatus()}\n\t\t\t{renderDisplay()}\n    </div>\n  );\n}\n\n//is there a better way of doing this\nconst gameOver = newTiles => {\n  for (let i = 0; i < dimension; i++) {\n    for (let j = 0; j < dimension; j++) {\n      if (newTiles[i][j] === winningTile) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// side effect: modify newTiles\nconst merge = (newTiles, row1, col1, row2, col2) => {\n  let currentVal = newTiles[row1][col1];\n  let adjacentVal = newTiles[row2][col2];\n  let newVal = currentVal + adjacentVal;\n  newTiles[row1][col1] = currentVal + adjacentVal;\n  newTiles[row2][col2] = 0;\n};\n\n// do \"sliding all the way\" when shift\nconst slideUp = (newTiles, col) => {\n  //slide incrementally\n  for (let row = 0; row < dimension - 1; row++) {\n    if (newTiles[row][col] === 0) {\n      let row2 = row + 1;\n      //slide next available non blank tile\n      while (row2 < dimension - 1 && newTiles[row2][col] === 0) {\n        row2 += 1;\n      }\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n  return newTiles;\n};\n\nconst slideLeft = (newTiles, row) => {\n  for (let col = 0; col < dimension - 1; col++) {\n    if (newTiles[row][col] === 0) {\n      let col2 = col + 1;\n      while (col2 < dimension - 1 && newTiles[row][col2] === 0) {\n        col2 += 1;\n      }\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n  return newTiles;\n};\n\nconst slideDown = (newTiles, col) => {\n  for (let row = dimension - 1; row > 0; row--) {\n    if (newTiles[row][col] === 0) {\n      let row2 = row - 1;\n      while (row2 > 0 && newTiles[row2][col] === 0) {\n        row2 -= 1;\n      }\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n  return newTiles;\n};\n\nconst slideRight = (newTiles, row) => {\n  for (let col = dimension - 1; col > 0; col--) {\n    if (newTiles[row][col] === 0) {\n      let col2 = col - 1;\n      while (col2 > 0 && newTiles[row][col2] === 0) {\n        col2 -= 1;\n      }\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n  return newTiles;\n};\n\nconst slideWholeBoard = (newTiles, direction) => {\n  for (let col = 0; col < dimension; col++) {\n    switch (direction) {\n      case DIRECTION.UP:\n        slideUp(newTiles, col);\n        break;\n      case DIRECTION.DOWN:\n        slideDown(newTiles, col);\n        break;\n      case DIRECTION.LEFT:\n        slideLeft(newTiles, col);\n        break;\n      case DIRECTION.RIGHT:\n        slideRight(newTiles, col);\n        break;\n      default:\n        console.log(\"not a direction\");\n      //do nothing\n    }\n  }\n};\n\n// modify board with merged tiles newTiles up one\nconst shiftUp = newTiles => {\n  for (let row = 0; row < dimension - 1; row++) {\n    for (let col = 0; col < dimension; col++) {\n      let nextRow = row + 1;\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n};\n\nconst shiftLeft = newTiles => {\n  for (let row = 0; row < dimension; row++) {\n    for (let col = 0; col < dimension - 1; col++) {\n      let nextCol = col + 1;\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n};\n\nconst shiftDown = newTiles => {\n  for (let row = dimension - 1; row > 0; row--) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextRow = row - 1;\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n};\n\nconst shiftRight = newTiles => {\n  for (let row = 0; row < dimension; row++) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextCol = col - 1;\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n};\n\nconst fullMerge = (newTiles, direction) => {\n  switch (direction) {\n    case DIRECTION.UP:\n      shiftUp(newTiles);\n      break;\n    case DIRECTION.DOWN:\n      shiftDown(newTiles);\n      break;\n    case DIRECTION.LEFT:\n      shiftLeft(newTiles);\n      break;\n    case DIRECTION.RIGHT:\n      shiftRight(newTiles);\n      break;\n    default:\n      console.log(\"not a direction\");\n    //do nothing\n  }\n};\n\n// return random row or col index\nconst getRandomIndex = () => {\n  return Math.floor(Math.random() * dimension);\n};\n\n// TO DO: detect if no empty tiles left or it will infinitely loop\n// generates new num in random spot and updates board\nconst generateNewNum = newTiles => {\n  let row = getRandomIndex();\n  let col = getRandomIndex();\n  if (newTiles[row][col] === 0) {\n    newTiles[row][col] = 2;\n  } else {\n    generateNewNum(newTiles);\n  }\n};\n\n// keep for testing\n// happens in one board update when key pressed\nconst fullShift = (newTiles, direction) => {\n  slideWholeBoard(newTiles, direction);\n  fullMerge(newTiles, direction);\n  slideWholeBoard(newTiles, direction);\n  return newTiles;\n};\n\nconst updateTiles = (tiles, direction) => {\n  var newTiles = [...tiles];\n  fullShift(newTiles, direction);\n  generateNewNum(newTiles);\n  return newTiles;\n};\n\nexport {\n\tBoard,\n  merge,\n  slideUp,\n  slideDown,\n  slideWholeBoard,\n  fullMerge,\n  fullShift,\n  updateTiles,\n  gameOver\n};\n"]},"metadata":{},"sourceType":"module"}