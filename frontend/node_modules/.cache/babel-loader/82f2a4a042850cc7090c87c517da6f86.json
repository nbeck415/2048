{"ast":null,"code":"import { dimension, DIRECTION } from \"./constants.js\"; // side effect: modify newTiles\n\nexport function merge(newTiles, row1, col1, row2, col2) {\n  let currentVal = newTiles[row1][col1];\n  let adjacentVal = newTiles[row2][col2];\n  newTiles[row1][col1] = currentVal + adjacentVal;\n  newTiles[row2][col2] = 0;\n} // do \"sliding all the way\" when shift\n\nexport function slideUp(newTiles, col) {\n  for (let row = 0; row < dimension - 1; row++) {\n    if (newTiles[row][col] == 0) {\n      let row2 = row + 1;\n\n      while (row2 < dimension - 1 && newTiles[row2][col] === 0) {\n        row2 += 1;\n      }\n\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n\n  return newTiles;\n}\n\nfunction slideLeft(newTiles, row) {\n  for (let col = 0; col < dimension - 1; col++) {\n    if (newTiles[row][col] == 0) {\n      let col2 = col + 1;\n\n      while (col2 < dimension - 1 && newTiles[row][col2] === 0) {\n        col2 += 1;\n      }\n\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n\n  return newTiles;\n}\n\nexport function slideDown(newTiles, col) {\n  for (let row = dimension - 1; row > 0; row--) {\n    if (newTiles[row][col] == 0) {\n      let row2 = row - 1;\n\n      while (row2 > 0 && newTiles[row2][col] === 0) {\n        row2 -= 1;\n      }\n\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n\n  return newTiles;\n}\n\nfunction slideRight(newTiles, row) {\n  for (let col = dimension - 1; col > 0; col--) {\n    if (newTiles[row][col] == 0) {\n      let col2 = col - 1;\n\n      while (col2 > 0 && newTiles[row][col2] === 0) {\n        col2 -= 1;\n      }\n\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n\n  return newTiles;\n}\n\nexport function slideWholeBoard(newTiles, direction) {\n  for (let col = 0; col < dimension; col++) {\n    switch (direction) {\n      case DIRECTION.UP:\n        slideUp(newTiles, col);\n        break;\n\n      case DIRECTION.DOWN:\n        slideDown(newTiles, col);\n        break;\n\n      case DIRECTION.LEFT:\n        slideLeft(newTiles, col);\n        break;\n\n      case DIRECTION.RIGHT:\n        slideRight(newTiles, col);\n        break;\n\n      default:\n        console.log('not a direction');\n      //do nothing\n    }\n  }\n} // modify board with merged tiles newTiles up one\n\nfunction shiftUp(newTiles) {\n  for (let row = 0; row < dimension - 1; row++) {\n    for (let col = 0; col < dimension; col++) {\n      let nextRow = row + 1;\n\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n}\n\nfunction shiftLeft(newTiles) {\n  for (let col = 0; col < dimension - 1; col++) {\n    for (let row = 0; row < dimension; row++) {\n      let nextCol = col + 1;\n\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n}\n\nfunction shiftDown(newTiles) {\n  for (let row = dimension - 1; row > 0; row--) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextRow = row - 1;\n\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n}\n\nfunction shiftRight(newTiles) {\n  for (let col = dimension - 1; col > 0; col--) {\n    for (let row = dimension - 1; row > 0; row--) {\n      let nextCol = col - 1;\n\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n}\n\nexport function fullMerge(newTiles, direction) {\n  switch (direction) {\n    case DIRECTION.UP:\n      shiftUp(newTiles);\n      break;\n\n    case DIRECTION.DOWN:\n      shiftDown(newTiles);\n      break;\n\n    case DIRECTION.LEFT:\n      shiftLeft(newTiles);\n      break;\n\n    case DIRECTION.RIGHT:\n      shiftRight(newTiles);\n      break;\n\n    default:\n      console.log('not a direction');\n    //do nothing\n  }\n} // TO DO: detect if no empty tiles left\n// generates new num in random spot and updates board\n\nfunction newNum(newTiles) {\n  let row = getRandomIndex();\n  let col = getRandomIndex();\n\n  if (tiles[row][col] === 0) {\n    newTiles[row][col] = 2;\n  } else {\n    newNum(tiles);\n  }\n\n  return newTiles;\n} // return random row or col index\n\n\nfunction getRandomIndex() {\n  return Math.floor(Math.random() * dimension);\n} // happens in one board update when key pressed\n\n\nexport function fullShift(tiles, direction) {\n  var newTiles = [...tiles];\n  slideWholeBoard(newTiles, direction);\n  fullMerge(newTiles, direction);\n}\nexport default {\n  merge,\n  slideUp,\n  slideDown,\n  slideWholeBoard,\n  fullMerge,\n  fullShift\n};","map":{"version":3,"sources":["/home/lregina/onboarding/2048/src/board.js"],"names":["dimension","DIRECTION","merge","newTiles","row1","col1","row2","col2","currentVal","adjacentVal","slideUp","col","row","slideLeft","slideDown","slideRight","slideWholeBoard","direction","UP","DOWN","LEFT","RIGHT","console","log","shiftUp","nextRow","shiftLeft","nextCol","shiftDown","shiftRight","fullMerge","newNum","getRandomIndex","tiles","Math","floor","random","fullShift"],"mappings":"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","sourcesContent":["import { dimension, DIRECTION} from \"./constants.js\"; \n\n// side effect: modify newTiles\nexport function merge(newTiles, row1, col1, row2, col2) {\n\tlet currentVal = newTiles[row1][col1];\n\tlet adjacentVal = newTiles[row2][col2];\n\tnewTiles[row1][col1] = currentVal + adjacentVal; \n\tnewTiles[row2][col2] = 0;\n}\n\n// do \"sliding all the way\" when shift\nexport function slideUp(newTiles, col){\n\tfor (let row = 0; row < dimension - 1; row++) {\n\t\tif (newTiles[row][col] == 0) {\n\t\t\tlet row2 = row + 1;\n\t\t\twhile (row2 < dimension - 1 && newTiles[row2][col] === 0) {\n\t\t\t\trow2 += 1;\n\t\t\t}\n\t\t\tmerge(newTiles, row, col, row2, col);\n\t\t}\t\n\t}\n\treturn newTiles;\n}\n\nfunction slideLeft(newTiles, row) {\n\tfor (let col = 0; col < dimension - 1; col ++) {\n\t\tif (newTiles[row][col] == 0) {\n\t\t\tlet col2 = col + 1;\n\t\t\twhile (col2 < dimension - 1 && newTiles[row][col2] === 0) {\n\t\t\t\tcol2 += 1;\n\t\t\t}\n\t\t\tmerge(newTiles, row, col, row, col2);\n\t\t}\t\n\t}\n\treturn newTiles;\n}\n\nexport function slideDown(newTiles, col){\n\tfor (let row = dimension - 1; row > 0; row--) {\n\t\tif (newTiles[row][col] == 0) {\n\t\t\tlet row2 = row - 1;\n\t\t\twhile (row2 > 0 && newTiles[row2][col] === 0) {\n\t\t\t\trow2 -= 1;\n\t\t\t}\n\t\t\tmerge(newTiles, row, col, row2, col);\n\t\t}\t\n\t}\n\treturn newTiles;\n}\n\nfunction slideRight(newTiles, row){\n\tfor (let col = dimension - 1; col > 0; col--) {\n\t\tif (newTiles[row][col] == 0) {\n\t\t\tlet col2 = col - 1;\n\t\t\twhile (col2 > 0 && newTiles[row][col2] === 0) {\n\t\t\t\tcol2 -= 1;\n\t\t\t}\n\t\t\tmerge(newTiles, row, col, row, col2);\n\t\t}\t\n\t}\n\treturn newTiles;\n}\n\nexport function slideWholeBoard(newTiles, direction) {\n\tfor (let col = 0; col < dimension; col++) {\n\t\tswitch(direction) {\n\t\t\tcase DIRECTION.UP:\n\t\t\t\tslideUp(newTiles, col);\t\t\n\t\t\t\tbreak;\n\t\t\tcase DIRECTION.DOWN:\n\t\t\t\tslideDown(newTiles, col);\n\t\t\t\tbreak;\n\t\t\tcase DIRECTION.LEFT:\n\t\t\t\tslideLeft(newTiles, col);\n\t\t\t\tbreak;\n\t\t\tcase DIRECTION.RIGHT:\n\t\t\t\tslideRight(newTiles, col);\n\t\t\t\tbreak;\n\t\t\tdefault: \n\t\t\t\tconsole.log('not a direction');\n\t\t\t\t//do nothing\n\t\t}\n\t}\n}\n\n// modify board with merged tiles newTiles up one\nfunction shiftUp(newTiles) {\n\tfor (let row = 0; row < dimension - 1; row++) {\n\t\tfor (let col = 0; col < dimension; col++) {\n\t\t\tlet nextRow = row + 1;\n\t\t\tif (newTiles[row][col] === newTiles[nextRow][col]) {\n\t\t\t\tmerge(newTiles, row, col, nextRow, col)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction shiftLeft(newTiles) {\n\tfor (let col = 0; col < dimension - 1; col++) {\n\t\tfor (let row = 0; row < dimension; row++) {\n\t\t\tlet nextCol = col + 1;\n\t\t\tif (newTiles[row][col] === newTiles[row][nextCol]) {\n\t\t\t\tmerge(newTiles, row, col, row, nextCol)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction shiftDown(newTiles) {\n\tfor (let row = dimension - 1; row > 0; row--) {\n\t\tfor (let col = dimension - 1; col > 0; col--) {\n\t\t\tlet nextRow = row - 1;\n\t\t\tif (newTiles[row][col] === newTiles[nextRow][col]) {\n\t\t\t\tmerge(newTiles, row, col, nextRow, col)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction shiftRight(newTiles) {\n\tfor (let col = dimension - 1; col > 0; col--) {\n\t\tfor (let row = dimension - 1; row > 0; row--) {\n\t\t\tlet nextCol = col - 1;\n\t\t\tif (newTiles[row][col] === newTiles[row][nextCol]) {\n\t\t\t\tmerge(newTiles, row, col, row, nextCol)\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function fullMerge(newTiles, direction) {\n\tswitch(direction) {\n\t\tcase DIRECTION.UP:\n\t\t\tshiftUp(newTiles);\n\t\t\tbreak;\n\t\tcase DIRECTION.DOWN:\n\t\t\tshiftDown(newTiles);\n\t\t\tbreak;\n\t\tcase DIRECTION.LEFT:\n\t\t\tshiftLeft(newTiles);\n\t\t\tbreak;\n\t\tcase DIRECTION.RIGHT:\n\t\t\tshiftRight(newTiles);\n\t\t\tbreak;\n\t\tdefault: \n\t\t\tconsole.log('not a direction');\n\t\t\t//do nothing\n\t}\n}\n\n// TO DO: detect if no empty tiles left\n// generates new num in random spot and updates board\nfunction newNum(newTiles) {\n\tlet row = getRandomIndex();\n\tlet col = getRandomIndex();\n  if (tiles[row][col] === 0) {\n    newTiles[row][col] = 2;\n  } else {\n    newNum(tiles);\n  }\n  return newTiles;\n}\n\n// return random row or col index\nfunction getRandomIndex() {\n  return Math.floor(Math.random() * dimension);\n}\n\n// happens in one board update when key pressed\nexport function fullShift(tiles, direction) {\n\tvar newTiles = [...tiles];\n\tslideWholeBoard(newTiles, direction);\n\tfullMerge(newTiles, direction);\n}\n\nexport default { \n\tmerge, \n\tslideUp, \n\tslideDown, \n\tslideWholeBoard, \n\tfullMerge,\n\tfullShift \n};\n"]},"metadata":{},"sourceType":"module"}