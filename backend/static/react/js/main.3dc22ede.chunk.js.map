{"version":3,"sources":["constants.js","components/Tile.js","components/Stopwatch.js","components/ScoreForm.js","components/Board.js","index.js"],"names":["DIRECTION","Tile","props","className","onClick","value","Stopwatch","useState","paused","setPaused","hours","minutes","seconds","time","setTime","tick","newHours","newMinutes","newSeconds","padTime","timeComponent","toString","padStart","useEffect","timerId","setInterval","clearInterval","formattedHours","formattedMinutes","formattedSeconds","timeString","setGameTime","formattedTime","ScoreForm","method","action","type","name","placeholder","score","Board","defaultProps","keyPressed","tiles","setTiles","gameOver","setGameOver","pressed","endTime","renderTile","i","j","renderRow","direction","newTiles","updateTiles","isGameOver","updateBoard","window","token","stopwatchTime","merge","row1","col1","row2","col2","currentVal","adjacentVal","slideUp","col","row","dimension","slideLeft","slideDown","slideRight","slideWholeBoard","console","log","fullMerge","nextRow","shiftUp","shiftDown","nextCol","shiftLeft","shiftRight","getRandomIndex","Math","floor","random","fullShift","generateNewNum","useKeyPress","setKeyPressed","downHandler","key","addEventListener","removeEventListener","ReactDOM","render","topScores","map","scoreValue","document","getElementById"],"mappings":"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","file":"js/main.3dc22ede.chunk.js","sourcesContent":["export const dimension = 4;\nexport const DIRECTION = {\n  UP: \"up\",\n  DOWN: \"down\",\n  LEFT: \"left\",\n  RIGHT: \"right\"\n};\nexport const winningTile = 16;\n","import React from \"react\";\nimport PropTypes from 'prop-types';\n\nconst Tile = props => {\n\tTile.propTypes = {\n\t\tonClick: PropTypes.func,\n\t\tvalue: PropTypes.number,\n\t}\n\n  return (\n    <button className=\"tile\" onClick={props.onClick}>\n      {props.value}\n    </button>\n  );\n};\n\nexport default Tile;\n","import React, { useState, useEffect } from \"react\";\nimport PropTypes from 'prop-types';\n\nconst Stopwatch = props => {\n\tStopwatch.propTypes = {\n\t\tsetGameTime: PropTypes.func,\n\t}\n\n  var [paused, setPaused] = useState(false);\n  var [time, setTime] = useState({\n    hours: 0,\n    minutes: 0,\n    seconds: 0\n  });\n\n  // let one second pass\n  const tick = () => {\n    if (paused) {\n      // do nothing if paused\n      return;\n    }\n    var newHours = time.hours;\n    var newMinutes = time.minutes;\n    var newSeconds = time.seconds + 1;\n    if (newSeconds === 60) {\n      setTime({\n        hours: time.hours,\n        minutes: time.minutes + 1,\n        seconds: 0\n      });\n      newSeconds = 0;\n      newMinutes += 1;\n    }\n    if (newMinutes === 60) {\n      newMinutes = 0;\n      newHours += 1;\n    }\n    setTime({\n      hours: newHours,\n      minutes: newMinutes,\n      seconds: newSeconds\n    });\n  };\n\n  // takes in int time component\n  const padTime = timeComponent => {\n    return timeComponent.toString().padStart(2, \"0\");\n  };\n\n  const formattedTime = () => {\n    var formattedHours = padTime(time.hours);\n    var formattedMinutes = padTime(time.minutes);\n    var formattedSeconds = padTime(time.seconds);\n    var timeString = `${formattedHours}: ${formattedMinutes}: ${formattedSeconds}`;\n    props.setGameTime(timeString);\n    return timeString;\n  };\n\n  useEffect(() => {\n    let timerId = setInterval(tick, 1000); // tick every 1000ms\n    return () => {\n      clearInterval(timerId);\n    };\n  });\n\n  const renderStopwatch = () => {\n    return (\n      <div>\n        <p>{formattedTime()}</p>\n        <button onClick={() => setPaused(!paused)}>\n          {paused ? \"Resume\" : \"Pause\"}\n        </button>\n      </div>\n    );\n  };\n  return (\n    <div>\n      <p>Time </p>\n      {renderStopwatch()}\n    </div>\n  );\n};\n\nexport default Stopwatch;\n","import React from \"react\";\nimport PropTypes from 'prop-types';\n\nconst ScoreForm = props => {\n\tScoreForm.propTypes = {\n\t\tscore: PropTypes.number, \n\t}\n\n\t//const handleSubmit = (event) => {\n\t\t//alert(\"submitted\");\n\t//}\n\n\treturn (\n\t\t//<form onSubmit={handleSubmit}>\n\t\t<form method='POST' action='/'>\n\t\t\t<input type=\"text\" name=\"name\" placeholder=\"Enter name\"/>\n\t\t\t<input type=\"text\" name=\"scoreValue\" value={props.score}/>\n\t\t\t<input type=\"submit\" value=\"Submit\"/>\n\t\t</form>\n\t);\n};\n\nexport default ScoreForm;\n","import React, { useState, useEffect } from \"react\";\nimport { dimension, DIRECTION, winningTile } from \"../constants.js\";\nimport Tile from \"./Tile.js\";\nimport Stopwatch from \"./Stopwatch.js\";\nimport ScoreForm from \"./ScoreForm.js\";\n\nconst Board = props => {\n\tBoard.propTypes = {\n\t\tkeyPressed: DIRECTION.isRequired,\n\t}\n\t\n\tBoard.defaultProps = {\n\t\tkeyPressed: DIRECTION.UP,\n\t}\n\n  let initialTiles = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];\n  const [tiles, setTiles] = useState(initialTiles);\n  const [gameOver, setGameOver] = useState(false);\n  const pressed = props.keyPressed;\n  const [time, setTime] = useState(\"00:00:00\");\n  var endTime = null;\n\n  const renderTile = (i, j) => {\n    return <Tile value={tiles[i][j]} />;\n  };\n  const renderStatus = () => {\n    if (gameOver) {\n      endTime = time;\n      return (\n\t\t\t\t<div>\n\t\t\t\t\t<p> You won! Your time is {endTime} </p>\n\t\t\t\t\t<ScoreForm score={endTime}/>\n\t\t\t\t\t<p>Token is: {window.token}</p>\n\t\t\t\t</div>\n\t\t\t);\n    }\n    return (\n      <Stopwatch\n        setGameTime={stopwatchTime => {\n          setTime(stopwatchTime);\n        }}\n      />\n    );\n  };\n  const renderRow = i => {\n    return (\n      <div className=\"board-row\">\n        {renderTile(i, 0)}\n        {renderTile(i, 1)}\n        {renderTile(i, 2)}\n        {renderTile(i, 3)}\n      </div>\n    );\n  };\n  const renderDisplay = () => {\n    if (gameOver) {\n      return (\n        <div>\n\t\t\t\t\t<p>Whoo!</p>\n        </div>\n      );\n    }\n    //if (gameOver) {\n    //return (\n    //<div>\n    //<GameOverDisplay />\n    //<p>End time: {time}</p>\n    //</div>\n    //);\n    //}\n    return (\n      <div>\n        {renderRow(0)}\n        {renderRow(1)}\n        {renderRow(2)}\n        {renderRow(3)}\n      </div>\n    );\n  };\n  const updateBoard = () => {\n    var direction = pressed.direction;\n    if (direction != null) {\n      // if valid key pressed\n      var newTiles = updateTiles(tiles, direction);\n      setTiles(newTiles);\n      setGameOver(isGameOver(tiles));\n    }\n  };\n  useEffect(() => {\n    updateBoard();\n  }, [pressed]);\n\n  return (\n    <div>\n      {renderStatus()}\n      {renderDisplay()}\n    </div>\n  );\n};\n\n//is there a better way of doing this\nconst isGameOver = newTiles => {\n  for (let i = 0; i < dimension; i++) {\n    for (let j = 0; j < dimension; j++) {\n      if (newTiles[i][j] === winningTile) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// side effect: modify newTiles\nconst merge = (newTiles, row1, col1, row2, col2) => {\n  let currentVal = newTiles[row1][col1];\n  let adjacentVal = newTiles[row2][col2];\n  newTiles[row1][col1] = currentVal + adjacentVal;\n  newTiles[row2][col2] = 0;\n};\n\n// do \"sliding all the way\" when shift\nconst slideUp = (newTiles, col) => {\n  //slide incrementally\n  for (let row = 0; row < dimension - 1; row++) {\n    if (newTiles[row][col] === 0) {\n      let row2 = row + 1;\n      //slide next available non blank tile\n      while (row2 < dimension - 1 && newTiles[row2][col] === 0) {\n        row2 += 1;\n      }\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n  return newTiles;\n};\n\nconst slideLeft = (newTiles, row) => {\n  for (let col = 0; col < dimension - 1; col++) {\n    if (newTiles[row][col] === 0) {\n      let col2 = col + 1;\n      while (col2 < dimension - 1 && newTiles[row][col2] === 0) {\n        col2 += 1;\n      }\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n  return newTiles;\n};\n\nconst slideDown = (newTiles, col) => {\n  for (let row = dimension - 1; row > 0; row--) {\n    if (newTiles[row][col] === 0) {\n      let row2 = row - 1;\n      while (row2 > 0 && newTiles[row2][col] === 0) {\n        row2 -= 1;\n      }\n      merge(newTiles, row, col, row2, col);\n    }\n  }\n  return newTiles;\n};\n\nconst slideRight = (newTiles, row) => {\n  for (let col = dimension - 1; col > 0; col--) {\n    if (newTiles[row][col] === 0) {\n      let col2 = col - 1;\n      while (col2 > 0 && newTiles[row][col2] === 0) {\n        col2 -= 1;\n      }\n      merge(newTiles, row, col, row, col2);\n    }\n  }\n  return newTiles;\n};\n\nconst slideWholeBoard = (newTiles, direction) => {\n  for (let col = 0; col < dimension; col++) {\n    switch (direction) {\n      case DIRECTION.UP:\n        slideUp(newTiles, col);\n        break;\n      case DIRECTION.DOWN:\n        slideDown(newTiles, col);\n        break;\n      case DIRECTION.LEFT:\n        slideLeft(newTiles, col);\n        break;\n      case DIRECTION.RIGHT:\n        slideRight(newTiles, col);\n        break;\n      default:\n        console.log(\"not a direction\");\n      //do nothing\n    }\n  }\n};\n\n// modify board with merged tiles newTiles up one\nconst shiftUp = newTiles => {\n  for (let row = 0; row < dimension - 1; row++) {\n    for (let col = 0; col < dimension; col++) {\n      let nextRow = row + 1;\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n};\n\nconst shiftLeft = newTiles => {\n  for (let row = 0; row < dimension; row++) {\n    for (let col = 0; col < dimension - 1; col++) {\n      let nextCol = col + 1;\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n};\n\nconst shiftDown = newTiles => {\n  for (let row = dimension - 1; row > 0; row--) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextRow = row - 1;\n      if (newTiles[row][col] === newTiles[nextRow][col]) {\n        merge(newTiles, row, col, nextRow, col);\n      }\n    }\n  }\n};\n\nconst shiftRight = newTiles => {\n  for (let row = 0; row < dimension; row++) {\n    for (let col = dimension - 1; col > 0; col--) {\n      let nextCol = col - 1;\n      if (newTiles[row][col] === newTiles[row][nextCol]) {\n        merge(newTiles, row, col, row, nextCol);\n      }\n    }\n  }\n};\n\nconst fullMerge = (newTiles, direction) => {\n  switch (direction) {\n    case DIRECTION.UP:\n      shiftUp(newTiles);\n      break;\n    case DIRECTION.DOWN:\n      shiftDown(newTiles);\n      break;\n    case DIRECTION.LEFT:\n      shiftLeft(newTiles);\n      break;\n    case DIRECTION.RIGHT:\n      shiftRight(newTiles);\n      break;\n    default:\n      console.log(\"not a direction\");\n    //do nothing\n  }\n};\n\n// return random row or col index\nconst getRandomIndex = () => {\n  return Math.floor(Math.random() * dimension);\n};\n\n// TO DO: detect if no empty tiles left or it will infinitely loop\n// generates new num in random spot and updates board\nconst generateNewNum = newTiles => {\n  let row = getRandomIndex();\n  let col = getRandomIndex();\n  if (newTiles[row][col] === 0) {\n    newTiles[row][col] = 2;\n  } else {\n    generateNewNum(newTiles);\n  }\n};\n\n// keep for testing\n// happens in one board update when key pressed\nconst fullShift = (newTiles, direction) => {\n  slideWholeBoard(newTiles, direction);\n  fullMerge(newTiles, direction);\n  slideWholeBoard(newTiles, direction);\n  return newTiles;\n};\n\nconst updateTiles = (tiles, direction) => {\n  var newTiles = [...tiles];\n  fullShift(newTiles, direction);\n  generateNewNum(newTiles);\n  return newTiles;\n};\n\nexport {\n  Board,\n  merge,\n  slideUp,\n  slideDown,\n  slideWholeBoard,\n  fullMerge,\n  fullShift,\n  updateTiles\n};\n","import React, { useState, useEffect } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { DIRECTION } from \"./constants.js\";\nimport { Board } from \"./components/Board.js\";\n\n// key press handler using vim keys\nconst useKeyPress = () => {\n  const [keyPressed, setKeyPressed] = useState({ direction: null });\n\n  const downHandler = ({ key }) => {\n    let pressed = null;\n    switch (key) {\n      case \"k\":\n        pressed = DIRECTION.UP;\n        break;\n      case \"j\":\n        pressed = DIRECTION.DOWN;\n        break;\n      case \"h\":\n        pressed = DIRECTION.LEFT;\n        break;\n      case \"l\":\n        pressed = DIRECTION.RIGHT;\n        break;\n      default:\n        pressed = null;\n        break;\n    }\n    setKeyPressed({ direction: pressed });\n  };\n\n  // Add event listeners\n  useEffect(() => {\n    window.addEventListener(\"keydown\", downHandler);\n\n    return () => {\n      window.removeEventListener(\"keydown\", downHandler);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n  return keyPressed;\n};\n\n\n\nconst Game = () => {\n  //const [gameOver, setGameOver] = useState(false);\n\tconsole.log(\"hallo\");\n\tvar topScores = window.token;\n\tconsole.log(topScores);\n\tconsole.log(\"bye\");\n\n\tconst displayScores = () => {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t{ topScores.map(score => \n\t\t\t\t\t<div key={score.name}>\n\t\t\t\t\t\t<p>{score.name}: {score.scoreValue} </p> \n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t);\n\t}\n\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <Board keyPressed={useKeyPress()} />\n      </div>\n\t\t\t<h2>High Scores</h2>\n\t\t\t{ displayScores()}\n    </div>\n  );\n};\n\n//<Board\n//keyPressed={useKeyPress()}\n//over={(isEnd) => {setGameOver(isEnd) }}\n///>\n//<GameContext.Provider value={{gameOver: true}}></GameContext.Provider>\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById(\"root\"));\n"],"sourceRoot":""}